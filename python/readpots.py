import lxml.etree
from eval_math import mathml

namespaces = {'c':'http://www.xml-cml.org/schema',
              'm':'http://www.w3.org/1998/Math/MathML'}

class potential:
    def __init__(self, xml_potential):
        self.xml_potential = xml_potential
        self.parameters = {}
        self.parameterUnits = {}
        self.parameterRefs = {}
        self.metadata = {}
        self.arguments = []
        self._parse(xml_potential)

    def asXHTML(self):
        """This method returns a fragment of XHTML representing the 
           potential. The fragment is rooted at a <div> to allow 
           multiple potentals to be serialised in a single html 
           document by the caller."""
        NS = "{http://www.w3.org/1999/xhtml}"
        root = lxml.etree.Element(NS+"div", attrib={"id": "CMLPotential"})
        # TODO - add the rest of the markup here
        # TODO - include argument to turn on and embedd SVG
        document = lxml.etree.ElementTree(root)
        return document

    def asSVG(self, min, max, step):
        """This method returns a SVG representation of the potential energy 
        as a function of distance. Makes use of Toby White's Pelote language 
        and XSLT transform. Note - the transform gives a buss error on some
        systems, notably my MacBook and debian Sarge systems."""
        hasXSLTproc = 0 # TODO - find some way to automate this. Set to 1 to enable XSLT
	if (hasXSLTproc == 1):
            transformDoc = lxml.etree.parse(source="XSLT/pelote.xsl")
            transform = lxml.etree.XSLT(transformDoc)
            result = transform(self._pelote(min, max, step))
        else:
            raise "XSLT protection fault."
        return result

    def _pelote(self, min, max, step):
        NS = "{http://www.uszla.me.uk/xsl/1.0/pelote}"
        root = lxml.etree.Element(NS+"plot")
        PI = lxml.etree.ProcessingInstruction("xml-stylesheet", 'type="text/xls" herf="http://www.uszla.me.uk/xsl/1.0/pelote/pelote.xls"')
#        root.append(PI)
        title = lxml.etree.SubElement(root, NS+"title")
        title.text = "Autogenerated plot of sompot"
        pointlist = lxml.etree.SubElement(root, NS+"pointList")
        x = min
        while x < max:
            value = self.func(x)
            point = lxml.etree.SubElement(pointlist, NS+"point")
            point.attrib["x"] = str(x)
            point.attrib["y"] = str(value)
            print str(x) + "=" + str(value)
            x = x + step
        document = lxml.etree.ElementTree(root)
        #docroot = document.getroot()
        #docroot.append(PI)
        return document      


    def _parse(self, xml):
        """This method takes the XML representation of
           the potential and populates the attributes.
           Intended to be called only by __init__"""

        # Read any metadataList
        elements = xml.xpath("c:metadataList/c:metadata[@name][@content]", namespaces)
        if len(elements) != 0:
            for item in elements:
                name = item.xpath("@name", namespaces)[0]
                content = item.xpath("@content", namespaces)[0]
                self.metadata[name] = content

        # Read parameters
        elements = xml.xpath("c:parameter", namespaces)
        if len(elements) != 0:
            for item in elements:
                name = item.xpath("@name", namespaces)[0]
                ref = item.xpath("@dictRef", namespaces)[0]
                value = item.xpath("c:scalar/text()", namespaces)[0]
                units = item.xpath("c:scalar/@units", namespaces)[0]
                self.parameters[name] = value
                self.parameterUnits[name] = units
                self.parameterRefs[name] = ref

        # Read arguments 
        elements = xml.xpath("c:expression/c:arg", namespaces)
        if len(elements) != 0:
            # print "Arguments:"
            for item in elements:
                name = item.xpath("@name", namespaces)[0]
                units = item.xpath("c:scalar/@units", namespaces)[0]
                # print "    " + name + " " + units
                self.arguments.append(name)
       
        # Read in MathML expression if avalable
        math = self.xml_potential.xpath(
            "c:expression/m:math", namespaces)
        if len(math) == 1:
            transDict = {self.arguments[0]: self.arguments[0]}
            transDict.update(self.parameters)
            result2 = mathml(math[0], transDict)
            result2.parseMML()
            self.func = result2.asPythonFunction()

        return

    def asText(self):
        print "Metadata dictionary:"
        print self.metadata
        print "Parameters:"
        print self.parameters
        print self.parameterUnits
        print self.parameterRefs
        print "Arguments:"
        print self.arguments
        return

    def asTABLE(self, delpot, cutpot):
        """Dumps (to STDOUT) a DL_Poly TABLE file for the potential 
           as per DL_Poly 2.17 manual page 140 - 141. Note that forces
           I'm assuming units of eV for potential and psudoforces and 
           calculating ngrid on the fly (this could cause a problem if
           delpot is too large). Final point, the 'force' is calculated 
           by finite differences at delpot / 10"""
     
        npoints = int(cutpot/delpot)
        header = "%-80s" % ("Auto generated FIELD file from CML. I hate fixed format input")
        print header
        record2 = "%-15.8f%-15.8f%-10i" % (delpot, cutpot, npoints)
        print record2
        atoms = "Not Implemented Not Implemented"
        print atoms
        # Calculate potential
        point = 0
        loc = 0
        r = 0
        line = ""
        while r < cutpot:
            if r == 0:
                E = 0
            else:
                E = self.func(r)
            point = point + 1
            loc = loc + 1
            r = (delpot*point)
            if loc == 4:
                loc = 0 
                line = line + "%15.8f" % E
                print line
                line = ""
            else:
                line = line + "%15.8f" % E
        if line != "":
            print line
        # Calculate "forces" 
        point = 0
        loc = 0
        r = 0
        line = ""
        while r < cutpot:
            if r == 0:
                G = 0
            else:
                G = -1 * r * (self.func(r-(delpot/10))-self.func(r+(delpot/10))/(2*(delpot/10)))
            point = point + 1
            loc = loc + 1
            r = (delpot*point)
            if loc == 4:
                loc = 0 
                line = line + "%15f" % G 
                print line
                line = ""
            else:
                line = line + "%15f" % G

        return


if __name__ == "__main__":
    import sys

    command = sys.argv[1]
    sourcefile = sys.argv[2]
    destfile = sys.argv[3]

    docRoot = lxml.etree.parse(source=sourcefile)
    allpots = docRoot.xpath("/c:cml/c:potentialList/c:potential", namespaces)

    for pot in allpots:
        mypot = potential(pot)
        if command == 'TABLE':
            #TODO - open filehandle on destfile and pass to asTable to write to.
            mypot.asTABLE(0.001, 10)
        elif command == 'text':
            #TODO - open filehandle on destfile and pass to asText to write to.
            mypot.asText()
        elif command == 'pelote':
            pelote =  mypot._pelote(0.1, 10, 0.1)
            pelote.write(destfile)
        elif command == 'svg':
            svg = mypot.asSVG(1.1, 10, 0.1)
            svg.write(destfile)
        elif command == 'html':
            html = mypot.asXHTML()
            html.write(destfile)
